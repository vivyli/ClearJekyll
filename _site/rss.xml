<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Notebook</title>
        <description>Notebook - chunmato</description>
        <link>http://chunmato.github.io</link>
        <link>http://chunmato.github.io</link>
        <lastBuildDate>2014-11-13T23:11:00+08:00</lastBuildDate>
        <pubDate>2014-11-13T23:11:00+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Folly源码分析(5) – 多线程锁</title>
                <description>
&lt;p&gt;Folly对多线程方面考虑地较多，串讲时候被告知其实现在每个产品都是这样的，对多线程的要求都非常高，Folly中的多线程中对于自旋锁（spinlock）特别实现了一下，实现了如下的自旋锁：&lt;/p&gt;

&lt;p&gt;SmallLocks(MicroSpinLock、PicoSpinLock)：两个非常小的互斥量类型（1byte和1bit），主要用于highly memory-constrained环境&lt;/p&gt;

&lt;p&gt;RWSpinLock(RWSpinLock、RWTicketSpinLock)：两个读写锁&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MicroSpinLock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用一个byte表示锁（uint8_t），锁有两种状态，分别是FREE和LOCKED。&lt;/p&gt;

&lt;p&gt;调用lock时，用一个while循环不断地尝试去获得锁（即调用try_lock），看是否可以将锁的状态置为LOCKED，对于获得锁的策略是&lt;/p&gt;

&lt;p&gt;前4000次每次失败都调用pause，之后每次失败sleep 0.5ms&lt;/p&gt;

&lt;p&gt;这样降低线程的上下文切换的开销。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;try_lock的实现是使用了汇编的cas操作，即compare and swap，在效率上比普通的做比较会高很多，代码如下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;lock; cmpxchgb %2, (%3);&amp;quot;&lt;/span&gt;
                 &lt;span class=&quot;s&quot;&gt;&amp;quot;setz %0;&amp;quot;&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;=r&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// cmpxchgb constrains this to be in %al&lt;/span&gt;
                   &lt;span class=&quot;s&quot;&gt;&amp;quot;q&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Needs to be byte-accessible&lt;/span&gt;
                   &lt;span class=&quot;s&quot;&gt;&amp;quot;r&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;memory&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;flags&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;PicoSpinLock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这也是一个自旋锁，提供了自旋锁的基本函数lock和unlock，另外它可以保存一个整型变量，提供了getData和setData来获得/设置保存在锁中的整数，前提是这个整数的最高位必须为0，以使用这个最高位作为锁的表示，即最高位是0表示FREE，为1表示LOCKED，如图示：&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/22/pico_spinlock.png&quot; alt=&quot;pico_spinlock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他实现与MicroSpinLock相同，如try_lock用汇编的原子cas实现，尝试获得锁的策略。&lt;/p&gt;

&lt;p&gt;这个锁的好处是在内存占用上几乎0消耗，因为一般无符号整型变量的最高位都是用不到的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RWSpinLock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个读写锁，比pthread_rwlock快并且低开销，主要特点是：&lt;/p&gt;

&lt;p&gt;当线程数量小于CPU数量的时候性能较好
线程数量大的时候会导致写饥饿（写锁获得必须在读锁都释放之后才能被获得）
最多支持2^30 – 1个reader
在数据结构上，使用了一个32位的整型来表示这个锁，并有3个状态标记：写锁、更新锁、读锁，图示如下&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/22/RWSpinLock.png&quot; alt=&quot;RWSpinLock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;写锁（Lockable）：只有在读、写、更新锁都没有的时候才能获得&lt;/p&gt;

&lt;p&gt;在实现上，不断尝试申请写锁，多次失败（1000次），主动让出CPU，并且，以后的每次申请失败都让出CPU。&lt;/p&gt;

&lt;p&gt;这样的优化的好处在于避免了频繁地切换上下文，但是却加剧了写饥饿，即在读者很多的情况下，写锁就非常难申请到，产生饥饿。&lt;/p&gt;

&lt;p&gt;大致代码如下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LIKELY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;try_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sched_yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1000次申请失败，调用sched_yield() 主动让出CPU&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WRITER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acq_rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 原子操作，判断lock(bits_)是否是0，&lt;/span&gt;
                                  &lt;span class=&quot;c1&quot;&gt;//只有在是0的时候也就是没有被获得任何锁的情况加才申请到写锁&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;读锁（SharedLockable）：没有写锁的时候可以获得&lt;/p&gt;

&lt;p&gt;同样是不断尝试申请锁，多次申请失败让出CPU，当申请成功过的时候给lock加4，即在高30位的计数器上加1，当释放锁的时候减1。&lt;/p&gt;

&lt;p&gt;大致代码如下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LIKELY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;try_lock_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sched_yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_lock_shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// fetch_add 比 compare_exchange 快100%&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;READER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UNLIKELY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WRITER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bits_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;READER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;更新锁（Upgradable）：与读锁一样，但可以升级成写锁，或者降级成读锁，用于那种需要先做判断，才决定是否需要加写锁的场景&lt;/p&gt;

&lt;p&gt;申请更新锁，同样多次申请失败（已经拥有更新锁或者写锁）让出CPU，能够被升级成写锁或者读锁，做法是先释放更新锁，再加锁，使用原子操作完成。&lt;/p&gt;

&lt;p&gt;大致代码如下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lock_upgrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;try_lock_upgrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sched_yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_lock_upgrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UPGRADED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 申请锁失败，不回滚UPGRADED位，因为已经有更新锁或者写锁了，如果只是写锁，当unlock的时候这个位会被清除&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UPGRADED&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WRITER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RWTicketSpinLock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RWSpinLock的问题是读写不平衡，在读者太多的时候，写锁就没办法获得了，RWTicketSpinLock一定程度上解决了这个不平衡的问题，解决方法为：&lt;/p&gt;

&lt;p&gt;当有一个线程在等待写锁的时候，读锁是无法再被加上的，直到所有读锁被释放的时候，写锁就可以被加上，一定程度平衡了读写不平衡。&lt;/p&gt;

&lt;p&gt;在实现上，使用了一个ticket，即32或者64位长度的union类型来做读、写锁的获得判断条件，如图示&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/22/RWTicketSpinLock.png&quot; alt=&quot;RWTicketSpinLock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如代码&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RWTicket&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FullInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;whole&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用于整个数据的拷贝&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HalfInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 代表read和write数据&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__extension__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;QuarterInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用于加锁限制的标记数据&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;QuarterInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
      &lt;span class=&quot;n&quot;&gt;QuarterInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;读锁、写锁获得的条件过程大致如下（比较绕）&lt;/p&gt;

&lt;p&gt;初始化&lt;/p&gt;

&lt;p&gt;user=0、read=0、write=0&lt;/p&gt;

&lt;p&gt;读锁&lt;/p&gt;

&lt;p&gt;只有当users=read的时候，读锁才可以被加上，否则申请锁失败。
读锁被加上后，read++，users++，封锁了写锁的申请，但是读锁还是可以申请
Unlock的时候， write++
写锁&lt;/p&gt;

&lt;p&gt;只有当users=write的时候，写锁才可以被加上，否则申请锁失败。
写锁被加上后，users++，封锁了读锁和写锁的申请
Unlock的时候，read++，write++
写锁等待&lt;/p&gt;

&lt;p&gt;给users++，封锁了读锁的申请，然后等待user++之前的users==write的时候获取写锁。&lt;/p&gt;

&lt;p&gt;自制算法示范举例图：&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/22/RWTicketSpinLock_Example.png&quot; alt=&quot;RWTicketSpinLock_Example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个锁中做的优化大致有：&lt;/p&gt;

&lt;p&gt;使用并行的SSE2并行指令，对多个连续地址的整数一个指令完成++操作
使用Pause指令让出，一方面可以降低CPU能耗，另外可以帮助CPU优化指令。
减少分支预测，令old.user=old.read，判断user和read是否相等的逻辑延迟到CAS操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly中的SpinLock中MicroSpinLock和PicoSpinLock缩短了锁需要表示的长度，以节省内存空间，由于cas的使用在效率上也有一定的提升。&lt;/p&gt;

&lt;p&gt;RWSpinLock在效率上由于上下文切换的开销降低，有一定的提高，但是却产生了饥饿问题，RWTicketSpinLock在获得写锁的时候封锁读锁的获得，一定程度上解决了读写不平衡的问题。&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/2012/09/22/folly-multithread-locks</link>
                <guid>http://chunmato.github.io/2012/09/22/folly-multithread-locks</guid>
                <pubDate>2012-09-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Folly源码分析(4) – 多线程数据结构</title>
                <description>
&lt;p&gt;Folly为多线程做了许多相关的组件和优化，例如之前介绍内存管理时的提到的ThreadCachedArena就为多线程的内存分配做优化，本文将会提到几个多线程相关的组件，如线程局部变量ThreadLocal、原子递增变量ThreadCachedInt、线程安全原子哈希AtomicHashMap、并发的跳表ConcurrentSkipList、高性能的生产者消费者队列ProducerConsumerQueue。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ThreadLocal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;线程局部变量是指只有在本线程中才能被访问到的数据，对于其他线程是屏蔽的，类似于线程范围的全局变量，如pthread_setspecific/pthread_getspecific实现了类似的功能。但是相比于pthread_setspecific/pthread_getspecific，ThreadLocal更为易用，只要定义ThreadLocalPtr&lt;xxx&gt;，这个对象就会为每个线程分配一个私有的变量，当线程退出的时候自动执行释放函数。&lt;/xxx&gt;&lt;/p&gt;

&lt;p&gt;当然线程局部变量的一种替代解决方案是让线程访问一个全局变量，使线程内部的各个函数就能共享一个变量，这样的缺陷主要有1）当一个线程挂掉时影响到其他线程；2）数据同步影响效率；因此线程局部变量是一个很有用的东西。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Folly对这个的类的优化主要有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;定义了模版参数Tag，每个Tag只是用1个pthread_key_t，原因是一般来说pthread_key_t的个数是有限的，一般是1024个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开发人员可以指定线程退出时执行的函数和所有线程退出后执行的函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供了accessAllThreads来遍历所有线程中的局部变量，这个被用在ThreadCachedInt的获得较为准确的数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Folly的文档中介绍了这个类的用法，例如&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;folly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadLocalPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customDeleterA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;customDeleterB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mangleWidget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Widget(1) is destroyed with customDeleterB&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Widget(0) is destroyed with customDeleterA&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// customDeleterB通过THIS_THREAD设定，当单个线程退出的时候调用&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// custonDeleterA通过ALL_THREAD设定，当所有线程退出的时候调用&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用accessAllThread遍历访问线程的私有数据&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleThreadCachedInt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NewTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Segments the global mutex&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ThreadLocal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// operator*() gives a reference to the thread local instance&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// accessAllThreads acquires the global lock&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accessAllThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Global lock is released on scope exit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ThreadLocal实现的数据结构大致如下&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/threadlocal.png&quot; alt=&quot;threadlocal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用一个全局静态元数据StaticMeta保存了线程数据ThreadEntity的头指针和一些用于管理的数据，当一个线程启动时需要将数据加入到线程私有变量中去的时候，在head的指向的私有数据链表中，而实际的数据时保存在elements的ElementWrap的数组中，其中的ptr指向于真正的数据，而每个ElementWrap都可以指定自己的资源释放函数Deleter。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ThreadCachedInt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个整型的类，主要用于多线程同时操作一个自增的整型变量，在精度保证不丢失的情况下提供极高的性能，在测试获得的结果是，它比std::atomic_fetch_add快10倍。&lt;/p&gt;

&lt;p&gt;提供了两种的对这个自增整型类的读取方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;readFast：速度很快（一个load指令得到的数据），但是数据有可能是以前的数据，即读到的数据比真是数据小，这种情况适用于对精度无太大要求，但是对效率要求很高的情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;readFull：速度相比于readFast慢，但是数据较为准确，做法事实上就是累加所有线程中的计数器和全局的计数器，在读取线程的数据的时候需要获得一个锁，因此效率比较差。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个类的数据结构示意图&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/threadcachedint.png&quot; alt=&quot;threadcachedint&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个示意图也示意了这个类的实现过程，即保存一个类全局变量和线程私有变量val，是ThreadLocalPtr，这个类就是上面介绍的ThreadLocal，当线程中的val更新次数超过一定次数的时候，将本线程中的计数器val加到全局的targe_中，本身的val清零。&lt;/p&gt;

&lt;p&gt;readFast直接读取target_的值&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;IntT&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;readFull则需要累加所有的值&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;IntT&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IntT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readFast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accessAllThreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reset_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;AtomicHashMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AtomicHashMap是一个几乎无锁的原子HashMap，几乎无所的意思是只有少量的几个方法是有锁的。&lt;/p&gt;

&lt;p&gt;这个类的文档和源代码的注释中解释了这个类的有点和缺点，如下&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高性能，特别是在多线程要求非常高的环境中
相比tbb::concurrent_has_map快2-5倍&lt;/li&gt;
  &lt;li&gt;好的内存利用率，容量不过估的前提下
良好的分散性能？（ Good fragmentation properties ）&lt;/li&gt;
  &lt;li&gt;查找快速&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺陷：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Key只支持int32、int64，原因是需要执行无所的cas（compare and swap）操作&lt;/li&gt;
  &lt;li&gt;必须指定empty、locked、erased的key，原因也是key的限制&lt;/li&gt;
  &lt;li&gt;性能会随着初始尺寸的容量的增大线性降低，原因是其数据结构的submap的查找&lt;/li&gt;
  &lt;li&gt;最大的size被限制在初始size的18倍&lt;/li&gt;
  &lt;li&gt;擦除的内存块不被释放，而是被标记擦除，为了效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据结构如下&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/atomichashmap.png&quot; alt=&quot;atomichashmap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个AtomicHashMap中最多包含16个subMap，subMap定义为AtomicHashArray，用数组实现的存储数据的hash 表。在初始化的时候只初始化1个SubMap，其他都置为null，当一个SubMap被放满时再初始化下一个SubMap。&lt;/p&gt;

&lt;p&gt;主要方法的实现大致如下&lt;/p&gt;

&lt;p&gt;Insert&lt;/p&gt;

&lt;p&gt;从第一个SubMap查找位置，使用线性的解决冲突，即有冲突，不断找相邻的下一个位置，若满则找下一个，若全满，则申请新的SubMap，大小为&lt;/p&gt;

&lt;p&gt;第一个SubMap的capacity * 1.8 ^ (nextIdx – 1)&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/atomichashmap_insert.png&quot; alt=&quot;atomichashmap_insert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里在查找key的时候使用了cas操作，以原子地对位置加锁，而在AtomicHashArray中每个key的状态有可能是Empty、Locked、Erased、真实的key，并且预留一定百分比的位置以缓冲，避免超过capacity。&lt;/p&gt;

&lt;p&gt;find&lt;/p&gt;

&lt;p&gt;过程如下：&lt;/p&gt;

&lt;p&gt;计算keyToAnchorIdx(key)的值，定位到对应的单元&lt;/p&gt;

&lt;p&gt;判断单元中存储的key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Key=key_in：查找成功，返回单元中的元素

    key≠key_in：

        Key=Empty：查找失败

        否则：查找下一个单元，直到找到元素或者超过capacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;erase&lt;/p&gt;

&lt;p&gt;操作与find一样，找到元素，标记为Erased&lt;/p&gt;

&lt;p&gt;其中find和erase是无等待的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConcurrentSkipList&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个支持并发的跳表，跳表是一个随机的链表结构，盗用网上的一张示意图对跳表进行描述&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/skiplist.png&quot; alt=&quot;skiplist&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都是随机高度，当查找的时候从高往低查找，当一层失败的时候就降低一层查找，知道找到或者找到最低层。&lt;/p&gt;

&lt;p&gt;Folly中实现的跳表的特点和缺陷主要有&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;较小的内存开销：比std::set小了~40%
Read操作时无锁几乎无等待的
快速，多线程环境下比带有一个RWSpinLock的std::set快了10倍以上
支持GC&lt;/p&gt;

&lt;p&gt;缺陷：&lt;/p&gt;

&lt;p&gt;写操作比std::set慢30%
每一个跳表都需要一个4-word的头结点
当元素个数较小（&amp;lt;1000）时，比std::set慢
只支持x64
释放的节点不可被重用
数据结构大致如下&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;800px&quot; src=&quot;/assets/images/2012/09/09/ConcurrentSkipList.png&quot; alt=&quot;ConcurrentSkipList&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存了内存回收类和跳表的头结点，每个结点的结构如头结点所示，使用了一个spinlock来对结点加锁，同时GC类中也记录了结点数据和这个类的引用数，每次被引用refs增加一次，当调用release时，refs减少一次，当refs=1时调用release的时候结点被析构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ProducerConsumerQueue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外Folly实现了一个队列长度确定的无等待的单producer单consumer的生产者消费者队列，这个类的实现就相对比较简单。&lt;/p&gt;

&lt;p&gt;用一个定长的数组表示循环队列，当调用write的时候往队列尾写数据，若满则返回false&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recordArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentWrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentWrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recordArgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;writeIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// queue is full&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用read读队列头的数据，若队列空则返回false&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// move (or copy) the value at the front of the queue to given variable&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentRead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentRead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// queue is empty&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentRead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;records_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;records_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readIndex_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextRecord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于C++11中对于内存读写顺序的方法的使用，对一些数据的原子读写就方便许多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly的多线程数据大致如上，线程局部变量ThreadLocal、原子递增变量ThreadCachedInt、线程安全原子哈希AtomicHashMap、并发的跳表ConcurrentSkipList、高性能的生产者消费者队列ProducerConsumerQueue，这些数据结构一方面在内存效率以及易用上有较大的优化，另外一方面也带来限制，如map中key的限制，对于元素个数的预估等，所以在一定条件下使用这些数据结构能够带来收益。&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/2012/09/09/folly-multithread</link>
                <guid>http://chunmato.github.io/2012/09/09/folly-multithread</guid>
                <pubDate>2012-09-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Folly源码分析(2) – 字符串</title>
                <description>
&lt;p&gt;本文主要介绍了Folly中两个字符串相关的类FBString和Range，主要是介绍FBString中的优化，Range不做具体介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FBString&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly实现了一个自己的字符串类fbstring，关于fbstring我之前看源代码的时候参考了博客园里的&lt;a href=&quot;http://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html&quot;&gt;一篇文章&lt;/a&gt;，讲的非常不错，所以我相当于是重复性劳动了。&lt;/p&gt;

&lt;p&gt;fbstring兼容了std::string的接口，属于重新造轮子，但是做了性能上的优化，主要有如下优化：&lt;/p&gt;

&lt;p&gt;内存模型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据存储&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存分配&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常用算法的优化&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;find算法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他优化&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;strong&gt;数据存储&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据存储的string的size，分成三种存储方式：&lt;/p&gt;

&lt;p&gt;Small：0-22个字符，存储到栈中，char[24]&lt;/p&gt;

&lt;p&gt;Medium：23-254个字符，使用malloc分配内存，使用eager-copy方式，即字符串的复制总是重新分配并拷贝内容&lt;/p&gt;

&lt;p&gt;Large：大于254个字符，存储方式与medium相同，在字符串之前存储了引用计数，使用lazy-copy，即copy-on-write，也就是说一般的引用只增加引用计数，只有在需要修改或者取下标操作的时候才对字符串进行copy，以减少内存拷贝的次数。&lt;/p&gt;

&lt;p&gt;这样做的好处在于当字符串长度较小的时候，直接做栈操作，效率上会高很多，当字符串较长的时候，由于代价的考虑，不能做频繁的拷贝操作，因此使用了copy-on-write，但同时由于copy-on-write本身的缺陷，如多线程的时候会增加其内存拷贝次数等等，在中等长度的时候则不适用copy-on-write。（事实上高版本的string类已经不再使用copy-on-write了）&lt;/p&gt;

&lt;p&gt;代码上的数据结构表示&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MediumLarge&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacity_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacity_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacityExtractMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;small_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MediumLarge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MediumLarge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ml_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ml_的大小正好为24，在实际存储中，small_的最后一位存储字符串的长度，倒数第二位保留给’\0′，所以small的时候最长能保存22个字符，而medium和large使用了相同的数据结构，不同点事large之前会保存一个RefCount，它是一个std::atomic&lt;size_t&gt;的原子整型。&lt;/size_t&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存分配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内存分配方面的优化使用了上篇中讲的Malloc.h，即一方面做了64B/256B/4KB/4MB的内存申请的对齐，令一方面优化了realloc操作，在内存扩张的时候先判断是否使用了jemalloc，若未使用则根据内存占用率判断是否使用realloc，具体可见上篇Folly相关的文章的Malloc.h部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;find算法优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;std::string中的find算法使用了KMP查找算法，而在Folly中使用了一种简化的Boyer-Moore算法，测试显示当查找成功时相比string::find提高了30倍，失败时提高了1.5倍。&lt;/p&gt;

&lt;p&gt;这个算法过程如下，举例说明&lt;/p&gt;

&lt;p&gt;例如：ABCDEFABCDEFGEFG中查找DEFGE&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;目标字符串（DEFGE）的最后一个字符是E，lastNeedle=’E’，找到源字符串中第一个lastNededle的位置，ABCDEFABCDEFGEFG&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从后往前比较，发现D!=G，因此不需要往前找，因为之前肯定不存在这个紫川，需要找下一个可能出现的地方。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ABCDEFABCDEFGEFG&lt;/p&gt;

&lt;p&gt;DEFGE&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在这一步不是逐个找，而是跳过目标串中距离lastNeedle与lastNeedle相同的两个字母的距离，此处为两个E的距离，skip=3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跳过skip（3）的距离ABCDEFABCDEFGEFG，即从B开始找下一个lastNeedle（E），为ABCDEFABCDEFGEFG&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不断循环查找，直到找到或者失败&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ABCDEFABCDEFGEFG
DEFGE&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;‘\0′的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于字符串预留末尾的’\0’，只在调用c_str()或者data()的时候添加，在一般的操作中保留着一位，而不再做添加和删除，减少了操作无用字符的开销，提高一定的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;word-wise copy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当是类型是small的时候，每次拷贝64bits数据，以提高拷贝的效率，如下&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byteSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Copy three words&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ml_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capacity_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
          &lt;span class=&quot;nl&quot;&gt;copyTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ml_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
          &lt;span class=&quot;nl&quot;&gt;copyOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;ml_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byteSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Copy two words&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Copy one word&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上就是string类的几个主要的优化，总结一下主要的优化点是1）根据string的长短优化其存储方式；2）在内存realloc的时候做优化；3）常用算法上的优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Range&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一个跟字符串有关的类是Range.h，这个类就没什么可写的，主要是封装了可随机访问的字符串StringPiece，与boost的Range相同，实现的目的是为了兼容接口。&lt;/p&gt;

&lt;p&gt;实现方法是：&lt;/p&gt;

&lt;p&gt;存储了两个指针b_和e_，分别为一个字符串片段的起始地址和结束地址，访问时访问地址偏移量&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/2012/08/20/folly-string</link>
                <guid>http://chunmato.github.io/2012/08/20/folly-string</guid>
                <pubDate>2012-08-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Folly源码分析(1) – 内存管理</title>
                <description>
&lt;p&gt;Folly中内存管理相关的类主要有Arena和ThreadCachedArena，另外针对内存申请做优化的是Malloc.h这个工具，本文主要对这三个类/工具做实现上的分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Arena&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Arena是一个类似于内存池的类，不同的是一般内存池都管理的被释放的内存，但是Arena无法释放内存，直到Arena本身被析构的时候才释放所有的内存块，这个类主要目的是作为ThreadCachedArena的实现。&lt;/p&gt;

&lt;p&gt;它提供了三个接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;void* allocate(size_t size); //申请内存一块size大小的内存块，加入Arena的内存链表中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;void merge(Arena&amp;amp;&amp;amp; other); //将另外一个Arena中的内存块合并到当前的Arena中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;void deallocate(void* p); //为接口兼容，实际上不做任何操作&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;数据结构&lt;/p&gt;

&lt;p&gt;内存的存放方式是使用了一个单向链表存储，cache了末端的节点&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intrusive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intrusive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member_hook&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockLink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intrusive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant_time_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intrusive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache_last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;存储的结构如下&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;900px&quot; src=&quot;/assets/images/2012/08/18/arena.png&quot; alt=&quot;arena&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以竖线为分界线，右边的都是定长（默认为4M）的内存块，左边为大于定长的内存块，ptr_和end_分别指向了链表末端的空闲块的开始和结束地址&lt;/p&gt;

&lt;p&gt;分配内存&lt;/p&gt;

&lt;p&gt;Arena的内存申请算法如下：&lt;/p&gt;

&lt;p&gt;1.当申请的内存块的size小于链表末端的空闲空间（即end&lt;em&gt;-ptr&lt;/em&gt;），则直接插入到链表末端的空间（以加快内存分配），否则分配内存块&lt;/p&gt;

&lt;p&gt;2.分配内存块：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当申请的内存块的大小大于minBlockSize（4M），则直接插入到链表的前面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当申请的内存块的大小小于或者等于minBlockSize（4M），则插入到链表的末端，并调整ptr_和end_的指向，指向于(minBlockSize – size)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;释放内存&lt;/p&gt;

&lt;p&gt;调用deallocate不做任何操作，在调用~Arena()时，逐个析构链表中的内存块&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ThreadCachedArena&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ThreadCachedArena封装了Arena，用作多线程中的内存分配，主旨是在多线程中，每个线程都有自己的一个Arena来做内存分配和管理，同时线程共用成为zombie的Arena，当线程退出时，这个线程中的内存不做释放操作，而是merge到zombie中，直到所有的线程已经退出，ThreadCachedArena被析构时，zombie中存放的内存才被释放。&lt;/p&gt;

&lt;p&gt;这样做都是为多线程环境的速度做考虑，线程申请内存不需要考虑线程同步，也减少了内存的释放操作，对性能有很大的提升。&lt;/p&gt;

&lt;p&gt;其数据的示意图大致如下，每个线程中的Arena用Folly中的ThreadLocalPtr存放，其作用与pthread_getspecific类似，每个线程都是独立拥有一个对象。&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;900px&quot; src=&quot;/assets/images/2012/08/18/threadcachedarena.png&quot; alt=&quot;threadcachedarena&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Malloc.h&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个包装glibc的malloc、calloc、realloc的工具，它的主要优化是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对size做了goodMallocSize过滤，将size做64B/256B/4KB/4MB对齐，以减少内存碎片&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实现smartRealloc函数，判断是否使用jemalloc，再做优化&lt;/p&gt;

    &lt;p&gt;2.1 当使用了jemalloc的时候，用jemalloc的rallocm代替std的realloc方法（jemalloc是FreeBSD上默认的分配器，在多线程并发环境下表现更好）&lt;/p&gt;

    &lt;p&gt;2.2 当没有使用jemallc，需要realloc的时候，根据内存块使用率，分情况处理处理，如示意图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img width=&quot;900px&quot; src=&quot;/assets/images/2012/08/18/malloc.png&quot; alt=&quot;malloc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.2.1 当内存使用率低于50%的时候，放弃使用realloc，因为realloc可能会拷贝整块内存，会导致效率低下，使用malloc-copy-free的方法，也就是先malloc一块大的内存，再把原内存中的数据copy过去，释放原内存&lt;/p&gt;

&lt;p&gt;2.2.2 否则使用realloc，因为realloc有一定的可能性是会在当前内存之后扩展出一块内存，则而不需要拷贝整块内存；若realloc扩展内存失败，则会做malloc一块新的内存，把原内存块整块拷贝过去（包括使用的和未使用的）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly中的内存相关的类就是如上，Arena是针对了多线程环境中的内存分配做优化，块内空闲段的利用、减少内存释放次数、以及内存局部变量的方法提高内存分配/释放的速度。&lt;/p&gt;

&lt;p&gt;Malloc.h主要是针对了glibc中realloc的缺陷做了优化，原因是在容器中往往是需要做realloc操作的，如vector、string等，一方面也是为多线程的性能考虑。&lt;/p&gt;

&lt;p&gt;以上都是个人理解，如有错误，请及时想告。&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/2012/08/18/folly-memory-management</link>
                <guid>http://chunmato.github.io/2012/08/18/folly-memory-management</guid>
                <pubDate>2012-08-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Folly Overview</title>
                <description>
&lt;p&gt;本文从整体上对Folly做一个简单的介绍，主要参考GitHub上Folly的文档，以及我读代码下来的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly是什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它是Facebook Open-source Library的简称，是一个在今年的6月份开源的基于C++11的基础库，作为对STL和boost的补充和增强，并非是替代，也就是说是实现了一些STL和boost中没有的组件，也对STL和boost中的部分组件做了性能上的增强。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;值得一提的是它的主要作者Andrei Alexandrescu，写过《Modern C++ Design》，精于模板编程，目前已经43岁，还奋战在coding的第一线，我想这样的人国内少有了吧。Folly代码写的非常漂亮，逻辑非常清晰，也很少有令人费解的写法，读起来比较舒服。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高效&lt;/p&gt;

&lt;p&gt;一方面在通用的数据结构结构中对算法速度和内存上做优化，相比于STL和boos中的组件（如string、vector）有较大的提高；&lt;/p&gt;

&lt;p&gt;另一方面实现了在特定场合（例如容器中的元素个数较少或者已知的前提下）具有较好的性能。&lt;/p&gt;

&lt;p&gt;易用&lt;/p&gt;

&lt;p&gt;组件相比以前的更加易用，如ThreadLocal；另外有借鉴了其他语言语法上的优势，如实现了类似于java的synronized关键字的SYNCHRONIZED宏，python的格式化Format工具等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly中有什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly的代码量并不多，50几个头文件，10几个cpp文件，多的2000多行，少的也就几行。&lt;/p&gt;

&lt;p&gt;主要包含了40几个组件，大致包括：&lt;/p&gt;

&lt;p&gt;内存管理：如Arena&lt;/p&gt;

&lt;p&gt;高性能的数据结构：如string、vector&lt;/p&gt;

&lt;p&gt;有用的数据结构：如直方图、延时队列&lt;/p&gt;

&lt;p&gt;多线程相关的优化：如线程本地内存、旋转锁&lt;/p&gt;

&lt;p&gt;工具：如Hash的实现&lt;/p&gt;

&lt;p&gt;我对组件做了一个简单的分类，接下来就根据这个顺序来逐个写&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内存管理：Arena ThreadCachedArena&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串：FBString Range Malloc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量：FBVector Traits small_vector sorted_vector_types&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多线程数据结构：ThreadLocal AtomicHashArray AtomicHashMap ThreadCachedInt ProducerConsumerQueue ConcurrentSkipList&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多线程锁：SmallLocks RWSpinLock&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整型编码：DiscriminatedPtr GroupVarint PackedSyncPtr&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有用的数据结构：dynamic Histogram TimeoutQueue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工具：Bits Conv Format String Unicode Synchronized json Random Hash&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简化编程：eventfd Foreach IntrusiveList Likely Preprocessor ScopeGuard StlAllocator&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://chunmato.github.io/c++/2012/08/14/folly-overview</link>
                <guid>http://chunmato.github.io/c++/2012/08/14/folly-overview</guid>
                <pubDate>2012-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>遥控器和迁移</title>
                <description>
&lt;p&gt;某次整理实验室整理出来的一个很早的东西——红外线开关&lt;/p&gt;

&lt;p&gt;可以学习红外线信号（如电视机遥控器），远程接收信号控制电源开关&lt;/p&gt;

&lt;p&gt;前一段时间拍了个视频，&lt;a href=&quot;http://v.youku.com/v_show/id_XNDE0MDIxNTgw.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;实验室陈龙彪同学的工作，已经发表在学术会议上，那天闲来无聊拍了一段&lt;/p&gt;

&lt;p&gt;利用NFC触发音乐的迁移（手机上或者音箱），&lt;a href=&quot;http://v.youku.com/v_show/id_XNDE0MDIwOTg4.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/idea/2012/06/16/remote-control-and-migration</link>
                <guid>http://chunmato.github.io/idea/2012/06/16/remote-control-and-migration</guid>
                <pubDate>2012-06-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>实验室一小时</title>
                <description>
&lt;p&gt;由于旁边的同学正在做实验，使用kinect截图，于是就简单地把他的实验数据拿过来拼接了一下，可以大致看出来这一个小时里的动作。&lt;/p&gt;

&lt;p&gt;视频由1000多张照片生成，由于是别人的实验数据，因此角度不是太好。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XNDA2MDcyMTcy.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;
</description>
                <link>http://chunmato.github.io/2012/06/15/one-hour-in-lab</link>
                <guid>http://chunmato.github.io/2012/06/15/one-hour-in-lab</guid>
                <pubDate>2012-06-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java的一些读书笔记</title>
                <description>
&lt;p&gt;Java的GC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何判断对象是否可以被GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有两个算法：1）引用计数法；2）根搜索法；&lt;/p&gt;

&lt;p&gt;引用计数法是指对象每被引用1次，对象中的引用计数器加1，引用失效时，计数器减1，直到计数器为0的时候，对象被标记为可回收。&lt;/p&gt;

&lt;p&gt;根搜索法是指从GC Roots开始建立一个引用的图，当一个对象到GC Roots的路径不存在时，对象可以标记为可回收，JAVA中使用的是这种方法。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;strong&gt;对象GC的过程？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当对象被标记为可回收时，JVM判断判断对象是否有必要执行finalize方法（只有当finalize方法未被执行过的时候才被认为需要执行finalize方法）。&lt;/p&gt;

&lt;p&gt;如需要执行finalize方法，把对象加入到F-Queue中，稍后由虚拟机调用其finalize方法，如对象调用完之后仍旧是被标记为可回收，这块对象所占的内存空间就被虚拟机回收了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存回收的基本算法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有四个算法：1）标记-清除算法；2）复制算法；3）标记-整理算法；4）分代收集算法。&lt;/p&gt;

&lt;p&gt;标记-清除算法，是指直接回收被标记的内存块。会产生许多不连续的内存块碎片。&lt;/p&gt;

&lt;p&gt;复制算法，把内存块分为大小相等的两个区，只使用其中1个区，当一块内存块用完时，把每块复制到另外一个区，并且使用的内存块处于连续的空间。&lt;/p&gt;

&lt;p&gt;标记-整理算法，是指内存块标记完之后，让所有使用的内存块向一端移动，然后清理掉端界意外的内存。&lt;/p&gt;

&lt;p&gt;分代收集算法，是指把JAVA堆根据对象存活周期分为新生代和老生代，根据每个代的特点采用适当的手机算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;各种垃圾收集器？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有：1）Serial；2）ParNew；3）Parallel Scavenge；4）Serial Old；5）Parallel Old；6）CMS(Concurrent Mark Sweep)；7）G1(Garbage First)；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java的引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java中引用主要有四类，分别是：1）Strong Reference；2）Soft Reference；3）Weak Reference；4）Phantom Reference；主要跟Java的GC有关。&lt;/p&gt;

&lt;p&gt;可以从java.lang.ref包里可以看到有几个类：SoftReference、WeakReference、PhantomReference，分别对应后面三种引用。&lt;/p&gt;

&lt;p&gt;Strong Reference，就是一般意义上的引用，类似于Object obj = new Object的引用，只要Strong Reference存在，GC就不会回收这个对象。&lt;/p&gt;

&lt;p&gt;Soft Reference，被Soft Reference引用的对象，只有当系统将要发生内存溢出一场之前，才会被回收这块内存。&lt;/p&gt;

&lt;p&gt;Weak Reference，被Weak Reference引用的对象，能生存到下次垃圾收集之前，可以使用一段代码解释。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Dead&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Alive&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出的是：&lt;/p&gt;

&lt;p&gt;Alive&lt;/p&gt;

&lt;p&gt;Alive&lt;/p&gt;

&lt;p&gt;Dead&lt;/p&gt;

&lt;p&gt;也就是说只有调用了GC只有，Weak Reference才失效，get不到任何东西，内存才被回收，而在调用GC之前，即使obj=null了，建立Weak Reference的对象还是能get到的。&lt;/p&gt;

&lt;p&gt;Phontom Reference，对对象的生存时间产生任何影响，只是希望能在GC回收内存块的时候收到一个系统通知。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;犄角旮旯的关键字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有3个犄角旮旯的关键字：strictfp、transient、native&lt;/p&gt;

&lt;p&gt;strictfp&lt;/p&gt;

&lt;p&gt;浮点数计算方法相关的关键词，可用于修饰类、接口和方法，在此关键词内的方法的浮点数计算都是符合IEEE 754标准的，可以保证可移植性。&lt;/p&gt;

&lt;p&gt;transient&lt;/p&gt;

&lt;p&gt;序列化相关的关键词，用于修饰用来Serializable类属性，这个属性在类序列化的时候不被序列化。如&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当改变a和b的值之后序列化，再从序列化文件中读取这个类之后，b的值为序列化之前的值，而a是0。&lt;/p&gt;

&lt;p&gt;native&lt;/p&gt;

&lt;p&gt;用于修饰Java类的方法，表示这个方法是原生的方法，是调用被编译后的库文件的。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Type a line: &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;User typed: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;MyImpOfPrompt&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些犄角旮旯的关键字目前开发中还没用到&lt;/p&gt;

&lt;p&gt;参考：《深入理解Java虚拟机——JVM高级特性与最佳实践》&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/java/2012/03/15/reading-java</link>
                <guid>http://chunmato.github.io/java/2012/03/15/reading-java</guid>
                <pubDate>2012-03-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ActiveMQ Android Client</title>
                <description>
&lt;p&gt;&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;ActiveMQ&lt;/a&gt;是一个JMS的消息队列的一种实现，在高并发的服务端用的较多，据称能够支持每秒20000的并发数据访问。&lt;/p&gt;

&lt;p&gt;他实现了JMS标准的基本操作，如点对点的消息收发，发布/订阅消息等等，并且支持了许多协议，如Openwire、REST、Stomp、XMPP等等，因此支持了多语言和多平台，它自带的Java库实现了openwire和stomp的访问，但是如要手机端（如Android）对JMS的支持很差（或者还不支持？），因此对于手机端来说操作ActiveMQ不得不使用XMPP或者REST。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;XMPP我尝试过，使用&lt;a href=&quot;http://www.igniterealtime.org/projects/smack/index.jsp&quot;&gt;smack&lt;/a&gt;，smack是一个XMPP的Java库，原本是用来做IM开发的（作为同一系列的&lt;a href=&quot;http://www.igniterealtime.org/projects/spark/index.jsp&quot;&gt;spark&lt;/a&gt;是XMPP的IM客户端，基于smack，&lt;a href=&quot;http://www.igniterealtime.org/projects/openfire/index.jsp&quot;&gt;Openfire&lt;/a&gt;是XMPP的服务器，因此spark+openfire能够搭建一个IM系统，同样ActiveMQ也可以作为XMPP的服务器，ActiveMQ+spark也可以搭建一个IM系统。）使用smack能够连接ActiveMQ，并建立一个Topic，向Topic队列发送消息，但是一直没有找到如何建立Queue，生产消息和消费消息。有人还特意为Android写了个&lt;a href=&quot;http://code.google.com/p/asmack/&quot;&gt;asmack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我最后还是采用了最简单的REST，因为这基本上是HTTP的GET/POST来做，不需要任何第三方库。&lt;/p&gt;

&lt;p&gt;我需要的操作有3个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;produce：向一个消息队列中发送消息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;consume：消费一个队列中的一条消息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;unsubscribe：撤销一个队列的一个conumer。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现比较简单，produce操作即向http://localhost:8161/demo/message POST一条HTTP请求，POST的数据如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;destination：队列名称&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;type：队列类型，queue或者topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TimeToLive：消息在队列中的有效期&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;body：消息的内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有一些能够设置，不过用处不是很大。&lt;/p&gt;

&lt;p&gt;consume操作则是向http://localhost:8161/demo/message GET一条HTTP请求，一般格式如：&lt;/p&gt;

&lt;p&gt;http://localhost:8161/demo/message/destination?type=queue&amp;amp;clientId=cid&amp;amp;readTimeout=timeout&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;destination：想要消费数据的队列名称&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;type：queue或者topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;clientId：客户端的ID，不同的ID对应不同的consumer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;readTimeout：读队列等待的时长，超过时长请求等待结束&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unsubscribe操作指的是取消队列的consumer，两个consumer同时在consume一个队列时REST请求似乎没有响应，因此在consume一条消息之后需要移除这个consumer，而这个操作是到了ActiveMQ 5.4.0之后才有这个操作。做法是向http://localhost:8161/demo/message POST一条请求，其中数据为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;action：为unsubscribe&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;clientId：要移除的consumer的id&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样手机端就可以与ActiveMQ通信。&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/2011/05/20/activemq-android-client</link>
                <guid>http://chunmato.github.io/2011/05/20/activemq-android-client</guid>
                <pubDate>2011-05-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>自动语言/编码检测算法</title>
                <description>
&lt;p&gt;Mozilla的自动编码检测代码参考了论文&lt;a href=&quot;http://www-archive.mozilla.org/projects/intl/UniversalCharsetDetection.html&quot;&gt;《A composite approach to language/encoding detection》&lt;/a&gt;，今天正好把这篇文章读了一下。文中总结了自动语言/编码检测的三种算法，做了比较，并提出了一个结合三种方法的算法。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h4 id=&quot;coding-scheme-method&quot;&gt;Coding scheme method&lt;/h4&gt;

&lt;p&gt;这是一个比较直观的方法，一般被用于multi-byte encodings，因为在multi-byte encoding中，并不是所有的code point被用到，因此可以逐个字节检测，当发现一个不合法的byte时就可以判断尝试的编码类型错误。&lt;/p&gt;

&lt;p&gt;在这个方法中，为每一种编码类型建立一个状态机，当输入一个字节时根据状态机转移状态，检测算法只需要关心这个状态机的三种状态：START、ME、ERROR，其中START表示开始状态；ME表示对与输入序列属于猜测的编码类型，并且不可能是其他编码的序列，因此可以可以直接给出猜测的结果；而ERROR则是输入字节序列是非法的，可以直接排除这个编码。&lt;/p&gt;

&lt;p&gt;这个方法 对于一些multi-byte的编码类型来说是比较有效的，如UTF-8、ISO2022-xx、HZ，但是对于如EUC-JP、EUC-CN、EUC-KR来说效果并不好，对与single-byte的编码效果很差， 能够处理任意的输入文本。&lt;/p&gt;

&lt;h4 id=&quot;character-distribution&quot;&gt;Character Distribution&lt;/h4&gt;

&lt;p&gt;Coding schema method是一个规则方法，而另外两种则是概率的方法：对字符的分别做一个统计，一般来说任何语言中，一些字符会比其他的字符出现的概率更好，如对于用简体中文（6763个字符）来说，512个字符的出现累积概率约80%；繁体中文约75%；日文约92%；韩文约98%。&lt;/p&gt;

&lt;p&gt;在这个方法中，对每个输入序列字符进行判断，将其分为两个“frequently used”和“not frequently used”，如果输入字符属于频繁出现的512个字符中，定义为“frequently used”，否则则为“not frequently used”。根据这个统计计算distribution ratio：&lt;/p&gt;

&lt;p&gt;Distribution Ratio = (“frequently used”数量) / （“not frequently used”数量）
定义：&lt;/p&gt;

&lt;p&gt;confidence level = （输入字符序列的distribution ratio） / （ideal distribution ratio）
其中ideal distribution ratio为根据训练语料库得到的数据，如简体中文中，512个字符出现的累积概率是0.79135，因此ideal distribution ratio = (0.79135) / (1 – 0.79135) =3.79&lt;/p&gt;

&lt;p&gt;使用这个方法计算每个输入序列的confidence level，得到最高的编码猜测结果。&lt;/p&gt;

&lt;p&gt;这个方法对于multi-byte编码效果较好，但只能处理特定的文本，因为需要文本的统计结果。&lt;/p&gt;

&lt;h4 id=&quot;char-sequence-distribution&quot;&gt;2-Char Sequence Distribution&lt;/h4&gt;

&lt;p&gt;Character Distribution方法是基于单个字符的，而这个方法则是基于连续两个字符的，并且结合了character distribution方法，定义了confidence level为：&lt;/p&gt;

&lt;p&gt;confidence level = (TotalSequence - NegativeSequenceCount) / TotalSequence * FrequentCharCount / TotalCharacter
其中TotalSequence：目标文本中的相邻字符序列数量&lt;/p&gt;

&lt;p&gt;NegativeSequenceCount：目标文本中的2-Char序列中，属于低概率出现序列数量&lt;/p&gt;

&lt;p&gt;FrequentCharCount：“frequently used”字符的数量&lt;/p&gt;

&lt;p&gt;TotalCharacter：字符总数&lt;/p&gt;

&lt;p&gt;这种方法对于single-byte的效果较好，而对于multi-byte的效果较差，当样本数量较小时效果好，只对特定的文本类型有效。&lt;/p&gt;

&lt;p&gt;因为这三种算法都只对特定的编码方式的检测效率较高，因此作者根据输入字符的类型分别用不同的方法进行检测，得到检测的结果。&lt;/p&gt;
</description>
                <link>http://chunmato.github.io/algorithm/2010/12/12/auto-language-detecting</link>
                <guid>http://chunmato.github.io/algorithm/2010/12/12/auto-language-detecting</guid>
                <pubDate>2010-12-12T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
