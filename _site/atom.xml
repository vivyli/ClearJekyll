<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Notebook</title>
 <link href="http://chunmato.github.io/" rel="self"/>
 <link href="http://chunmato.github.io"/>
 <updated>2014-11-13T01:22:07+08:00</updated>
 <id>http://chunmato.github.io</id>
 <author>
   <name>chunmato</name>
   <email>vivylics@gmail.com</email>
 </author>

 
 <entry>
   <title>Folly Overview</title>
   <link href="http://chunmato.github.io/c++/2012/08/14/folly-overview"/>
   <updated>2012-08-14T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/c++/2012/08/14/folly-overview</id>
   <content type="html">
&lt;p&gt;本文从整体上对Folly做一个简单的介绍，主要参考GitHub上Folly的文档，以及我读代码下来的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly是什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它是Facebook Open-source Library的简称，是一个在今年的6月份开源的基于C++11的基础库，作为对STL和boost的补充和增强，并非是替代，也就是说是实现了一些STL和boost中没有的组件，也对STL和boost中的部分组件做了性能上的增强。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;值得一提的是它的主要作者Andrei Alexandrescu，写过《Modern C++ Design》，精于模板编程，目前已经43岁，还奋战在coding的第一线，我想这样的人国内少有了吧。Folly代码写的非常漂亮，逻辑非常清晰，也很少有令人费解的写法，读起来比较舒服。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly的特点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高效&lt;/p&gt;

&lt;p&gt;一方面在通用的数据结构结构中对算法速度和内存上做优化，相比于STL和boos中的组件（如string、vector）有较大的提高；&lt;/p&gt;

&lt;p&gt;另一方面实现了在特定场合（例如容器中的元素个数较少或者已知的前提下）具有较好的性能。&lt;/p&gt;

&lt;p&gt;易用&lt;/p&gt;

&lt;p&gt;组件相比以前的更加易用，如ThreadLocal；另外有借鉴了其他语言语法上的优势，如实现了类似于java的synronized关键字的SYNCHRONIZED宏，python的格式化Format工具等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Folly中有什么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Folly的代码量并不多，50几个头文件，10几个cpp文件，多的2000多行，少的也就几行。&lt;/p&gt;

&lt;p&gt;主要包含了40几个组件，大致包括：&lt;/p&gt;

&lt;p&gt;内存管理：如Arena&lt;/p&gt;

&lt;p&gt;高性能的数据结构：如string、vector&lt;/p&gt;

&lt;p&gt;有用的数据结构：如直方图、延时队列&lt;/p&gt;

&lt;p&gt;多线程相关的优化：如线程本地内存、旋转锁&lt;/p&gt;

&lt;p&gt;工具：如Hash的实现&lt;/p&gt;

&lt;p&gt;我对组件做了一个简单的分类，接下来就根据这个顺序来逐个写&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内存管理：Arena ThreadCachedArena&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串：FBString Range Malloc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量：FBVector Traits small_vector sorted_vector_types&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多线程数据结构：ThreadLocal AtomicHashArray AtomicHashMap ThreadCachedInt ProducerConsumerQueue ConcurrentSkipList&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多线程锁：SmallLocks RWSpinLock&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整型编码：DiscriminatedPtr GroupVarint PackedSyncPtr&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有用的数据结构：dynamic Histogram TimeoutQueue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工具：Bits Conv Format String Unicode Synchronized json Random Hash&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简化编程：eventfd Foreach IntrusiveList Likely Preprocessor ScopeGuard StlAllocator&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>遥控器和迁移</title>
   <link href="http://chunmato.github.io/idea/2012/06/16/remote-control-and-migration"/>
   <updated>2012-06-16T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/idea/2012/06/16/remote-control-and-migration</id>
   <content type="html">
&lt;p&gt;某次整理实验室整理出来的一个很早的东西——红外线开关&lt;/p&gt;

&lt;p&gt;可以学习红外线信号（如电视机遥控器），远程接收信号控制电源开关&lt;/p&gt;

&lt;p&gt;前一段时间拍了个视频，&lt;a href=&quot;http://v.youku.com/v_show/id_XNDE0MDIxNTgw.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;实验室陈龙彪同学的工作，已经发表在学术会议上，那天闲来无聊拍了一段&lt;/p&gt;

&lt;p&gt;利用NFC触发音乐的迁移（手机上或者音箱），&lt;a href=&quot;http://v.youku.com/v_show/id_XNDE0MDIwOTg4.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>实验室一小时</title>
   <link href="http://chunmato.github.io/2012/06/15/one-hour-in-lab"/>
   <updated>2012-06-15T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/2012/06/15/one-hour-in-lab</id>
   <content type="html">
&lt;p&gt;由于旁边的同学正在做实验，使用kinect截图，于是就简单地把他的实验数据拿过来拼接了一下，可以大致看出来这一个小时里的动作。&lt;/p&gt;

&lt;p&gt;视频由1000多张照片生成，由于是别人的实验数据，因此角度不是太好。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XNDA2MDcyMTcy.html&quot;&gt;视频点我&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;
</content>
 </entry>
 
 <entry>
   <title>Java的一些读书笔记</title>
   <link href="http://chunmato.github.io/java/2012/03/15/reading-java"/>
   <updated>2012-03-15T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/java/2012/03/15/reading-java</id>
   <content type="html">
&lt;p&gt;Java的GC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何判断对象是否可以被GC？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有两个算法：1）引用计数法；2）根搜索法；&lt;/p&gt;

&lt;p&gt;引用计数法是指对象每被引用1次，对象中的引用计数器加1，引用失效时，计数器减1，直到计数器为0的时候，对象被标记为可回收。&lt;/p&gt;

&lt;p&gt;根搜索法是指从GC Roots开始建立一个引用的图，当一个对象到GC Roots的路径不存在时，对象可以标记为可回收，JAVA中使用的是这种方法。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;strong&gt;对象GC的过程？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当对象被标记为可回收时，JVM判断判断对象是否有必要执行finalize方法（只有当finalize方法未被执行过的时候才被认为需要执行finalize方法）。&lt;/p&gt;

&lt;p&gt;如需要执行finalize方法，把对象加入到F-Queue中，稍后由虚拟机调用其finalize方法，如对象调用完之后仍旧是被标记为可回收，这块对象所占的内存空间就被虚拟机回收了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存回收的基本算法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有四个算法：1）标记-清除算法；2）复制算法；3）标记-整理算法；4）分代收集算法。&lt;/p&gt;

&lt;p&gt;标记-清除算法，是指直接回收被标记的内存块。会产生许多不连续的内存块碎片。&lt;/p&gt;

&lt;p&gt;复制算法，把内存块分为大小相等的两个区，只使用其中1个区，当一块内存块用完时，把每块复制到另外一个区，并且使用的内存块处于连续的空间。&lt;/p&gt;

&lt;p&gt;标记-整理算法，是指内存块标记完之后，让所有使用的内存块向一端移动，然后清理掉端界意外的内存。&lt;/p&gt;

&lt;p&gt;分代收集算法，是指把JAVA堆根据对象存活周期分为新生代和老生代，根据每个代的特点采用适当的手机算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;各种垃圾收集器？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有：1）Serial；2）ParNew；3）Parallel Scavenge；4）Serial Old；5）Parallel Old；6）CMS(Concurrent Mark Sweep)；7）G1(Garbage First)；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java的引用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java中引用主要有四类，分别是：1）Strong Reference；2）Soft Reference；3）Weak Reference；4）Phantom Reference；主要跟Java的GC有关。&lt;/p&gt;

&lt;p&gt;可以从java.lang.ref包里可以看到有几个类：SoftReference、WeakReference、PhantomReference，分别对应后面三种引用。&lt;/p&gt;

&lt;p&gt;Strong Reference，就是一般意义上的引用，类似于Object obj = new Object的引用，只要Strong Reference存在，GC就不会回收这个对象。&lt;/p&gt;

&lt;p&gt;Soft Reference，被Soft Reference引用的对象，只有当系统将要发生内存溢出一场之前，才会被回收这块内存。&lt;/p&gt;

&lt;p&gt;Weak Reference，被Weak Reference引用的对象，能生存到下次垃圾收集之前，可以使用一段代码解释。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Dead&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Alive&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WeakReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出的是：&lt;/p&gt;

&lt;p&gt;Alive&lt;/p&gt;

&lt;p&gt;Alive&lt;/p&gt;

&lt;p&gt;Dead&lt;/p&gt;

&lt;p&gt;也就是说只有调用了GC只有，Weak Reference才失效，get不到任何东西，内存才被回收，而在调用GC之前，即使obj=null了，建立Weak Reference的对象还是能get到的。&lt;/p&gt;

&lt;p&gt;Phontom Reference，对对象的生存时间产生任何影响，只是希望能在GC回收内存块的时候收到一个系统通知。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;犄角旮旯的关键字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要有3个犄角旮旯的关键字：strictfp、transient、native&lt;/p&gt;

&lt;p&gt;strictfp&lt;/p&gt;

&lt;p&gt;浮点数计算方法相关的关键词，可用于修饰类、接口和方法，在此关键词内的方法的浮点数计算都是符合IEEE 754标准的，可以保证可移植性。&lt;/p&gt;

&lt;p&gt;transient&lt;/p&gt;

&lt;p&gt;序列化相关的关键词，用于修饰用来Serializable类属性，这个属性在类序列化的时候不被序列化。如&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当改变a和b的值之后序列化，再从序列化文件中读取这个类之后，b的值为序列化之前的值，而a是0。&lt;/p&gt;

&lt;p&gt;native&lt;/p&gt;

&lt;p&gt;用于修饰Java类的方法，表示这个方法是原生的方法，是调用被编译后的库文件的。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;Prompt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Type a line: &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;User typed: &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;MyImpOfPrompt&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些犄角旮旯的关键字目前开发中还没用到&lt;/p&gt;

&lt;p&gt;参考：《深入理解Java虚拟机——JVM高级特性与最佳实践》&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ActiveMQ Android Client</title>
   <link href="http://chunmato.github.io/2011/05/20/activemq-android-client"/>
   <updated>2011-05-20T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/2011/05/20/activemq-android-client</id>
   <content type="html">
&lt;p&gt;&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;ActiveMQ&lt;/a&gt;是一个JMS的消息队列的一种实现，在高并发的服务端用的较多，据称能够支持每秒20000的并发数据访问。&lt;/p&gt;

&lt;p&gt;他实现了JMS标准的基本操作，如点对点的消息收发，发布/订阅消息等等，并且支持了许多协议，如Openwire、REST、Stomp、XMPP等等，因此支持了多语言和多平台，它自带的Java库实现了openwire和stomp的访问，但是如要手机端（如Android）对JMS的支持很差（或者还不支持？），因此对于手机端来说操作ActiveMQ不得不使用XMPP或者REST。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;XMPP我尝试过，使用&lt;a href=&quot;http://www.igniterealtime.org/projects/smack/index.jsp&quot;&gt;smack&lt;/a&gt;，smack是一个XMPP的Java库，原本是用来做IM开发的（作为同一系列的&lt;a href=&quot;http://www.igniterealtime.org/projects/spark/index.jsp&quot;&gt;spark&lt;/a&gt;是XMPP的IM客户端，基于smack，&lt;a href=&quot;http://www.igniterealtime.org/projects/openfire/index.jsp&quot;&gt;Openfire&lt;/a&gt;是XMPP的服务器，因此spark+openfire能够搭建一个IM系统，同样ActiveMQ也可以作为XMPP的服务器，ActiveMQ+spark也可以搭建一个IM系统。）使用smack能够连接ActiveMQ，并建立一个Topic，向Topic队列发送消息，但是一直没有找到如何建立Queue，生产消息和消费消息。有人还特意为Android写了个&lt;a href=&quot;http://code.google.com/p/asmack/&quot;&gt;asmack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我最后还是采用了最简单的REST，因为这基本上是HTTP的GET/POST来做，不需要任何第三方库。&lt;/p&gt;

&lt;p&gt;我需要的操作有3个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;produce：向一个消息队列中发送消息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;consume：消费一个队列中的一条消息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;unsubscribe：撤销一个队列的一个conumer。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现比较简单，produce操作即向http://localhost:8161/demo/message POST一条HTTP请求，POST的数据如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;destination：队列名称&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;type：队列类型，queue或者topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TimeToLive：消息在队列中的有效期&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;body：消息的内容&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有一些能够设置，不过用处不是很大。&lt;/p&gt;

&lt;p&gt;consume操作则是向http://localhost:8161/demo/message GET一条HTTP请求，一般格式如：&lt;/p&gt;

&lt;p&gt;http://localhost:8161/demo/message/destination?type=queue&amp;amp;clientId=cid&amp;amp;readTimeout=timeout&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;destination：想要消费数据的队列名称&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;type：queue或者topic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;clientId：客户端的ID，不同的ID对应不同的consumer&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;readTimeout：读队列等待的时长，超过时长请求等待结束&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;unsubscribe操作指的是取消队列的consumer，两个consumer同时在consume一个队列时REST请求似乎没有响应，因此在consume一条消息之后需要移除这个consumer，而这个操作是到了ActiveMQ 5.4.0之后才有这个操作。做法是向http://localhost:8161/demo/message POST一条请求，其中数据为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;action：为unsubscribe&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;clientId：要移除的consumer的id&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样手机端就可以与ActiveMQ通信。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>自动语言/编码检测算法</title>
   <link href="http://chunmato.github.io/algorithm/2010/12/12/auto-language-detecting"/>
   <updated>2010-12-12T00:00:00+08:00</updated>
   <id>http://chunmato.github.io/algorithm/2010/12/12/auto-language-detecting</id>
   <content type="html">
&lt;p&gt;Mozilla的自动编码检测代码参考了论文[《A composite approach to language/encoding detection》] (http://www-archive.mozilla.org/projects/intl/UniversalCharsetDetection.html)，今天正好把这篇文章读了一下。文中总结了自动语言/编码检测的三种算法，做了比较，并提出了一个结合三种方法的算法。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h4 id=&quot;coding-scheme-method&quot;&gt;Coding scheme method&lt;/h4&gt;

&lt;p&gt;这是一个比较直观的方法，一般被用于multi-byte encodings，因为在multi-byte encoding中，并不是所有的code point被用到，因此可以逐个字节检测，当发现一个不合法的byte时就可以判断尝试的编码类型错误。&lt;/p&gt;

&lt;p&gt;在这个方法中，为每一种编码类型建立一个状态机，当输入一个字节时根据状态机转移状态，检测算法只需要关心这个状态机的三种状态：START、ME、ERROR，其中START表示开始状态；ME表示对与输入序列属于猜测的编码类型，并且不可能是其他编码的序列，因此可以可以直接给出猜测的结果；而ERROR则是输入字节序列是非法的，可以直接排除这个编码。&lt;/p&gt;

&lt;p&gt;这个方法 对于一些multi-byte的编码类型来说是比较有效的，如UTF-8、ISO2022-xx、HZ，但是对于如EUC-JP、EUC-CN、EUC-KR来说效果并不好，对与single-byte的编码效果很差， 能够处理任意的输入文本。&lt;/p&gt;

&lt;h4 id=&quot;character-distribution&quot;&gt;Character Distribution&lt;/h4&gt;

&lt;p&gt;Coding schema method是一个规则方法，而另外两种则是概率的方法：对字符的分别做一个统计，一般来说任何语言中，一些字符会比其他的字符出现的概率更好，如对于用简体中文（6763个字符）来说，512个字符的出现累积概率约80%；繁体中文约75%；日文约92%；韩文约98%。&lt;/p&gt;

&lt;p&gt;在这个方法中，对每个输入序列字符进行判断，将其分为两个“frequently used”和“not frequently used”，如果输入字符属于频繁出现的512个字符中，定义为“frequently used”，否则则为“not frequently used”。根据这个统计计算distribution ratio：&lt;/p&gt;

&lt;p&gt;Distribution Ratio = (“frequently used”数量) / （“not frequently used”数量）
定义：&lt;/p&gt;

&lt;p&gt;confidence level = （输入字符序列的distribution ratio） / （ideal distribution ratio）
其中ideal distribution ratio为根据训练语料库得到的数据，如简体中文中，512个字符出现的累积概率是0.79135，因此ideal distribution ratio = (0.79135) / (1 – 0.79135) =3.79&lt;/p&gt;

&lt;p&gt;使用这个方法计算每个输入序列的confidence level，得到最高的编码猜测结果。&lt;/p&gt;

&lt;p&gt;这个方法对于multi-byte编码效果较好，但只能处理特定的文本，因为需要文本的统计结果。&lt;/p&gt;

&lt;h4 id=&quot;char-sequence-distribution&quot;&gt;2-Char Sequence Distribution&lt;/h4&gt;

&lt;p&gt;Character Distribution方法是基于单个字符的，而这个方法则是基于连续两个字符的，并且结合了character distribution方法，定义了confidence level为：&lt;/p&gt;

&lt;p&gt;confidence level = (TotalSequence - NegativeSequenceCount) / TotalSequence * FrequentCharCount / TotalCharacter
其中TotalSequence：目标文本中的相邻字符序列数量&lt;/p&gt;

&lt;p&gt;NegativeSequenceCount：目标文本中的2-Char序列中，属于低概率出现序列数量&lt;/p&gt;

&lt;p&gt;FrequentCharCount：“frequently used”字符的数量&lt;/p&gt;

&lt;p&gt;TotalCharacter：字符总数&lt;/p&gt;

&lt;p&gt;这种方法对于single-byte的效果较好，而对于multi-byte的效果较差，当样本数量较小时效果好，只对特定的文本类型有效。&lt;/p&gt;

&lt;p&gt;因为这三种算法都只对特定的编码方式的检测效率较高，因此作者根据输入字符的类型分别用不同的方法进行检测，得到检测的结果。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
